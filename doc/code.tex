The code used for this project was written using C++.  It was broken into five distinct pieces in order to maintain organization and at least some level of abstraction.  Each of these pieces will be described in sections \ref{ss:utils}-\ref{ss:driver}.

\subsection{Utils}\label{ss:utils}

This module contains functions which will be needed throughout the code and are not tied to any specific functionality.  Some of these functions are as follows:

\begin{itemize}
\item \textit{double drand(void)} -- This function uses the intrinsic C function \textit{int rand()} to return a random double precision number between 0.0 and 1.0.
\item \textit{double Watt(void)} -- This function returns a random energy for a fission neutron, sampled from the Watt spectrum.
\item \textit{bool approxeq(double, double)}, \textit{bool approxge(double, double)}, \textit{bool approxle(double, double)} -- These functions are used for $==$, $\ge$, and $\le$ operators, respectively, for floating point double precision numbers.
\end{itemize}

In addition to these functions, the header file for Utils also defines many constants for use in the code, such as pi, the mass of a neutron, the Boltzmann constant, and others used for various parts of the code.

The header file is found in Appendix A, and the source code in Appendix B.

\subsection{Geometry}\label{ss:geometry}

The second module is the geometry module.  This defines all the functions required for two main classes: \textit{cell} and \textit{surface}.

The \textit{surface} class has two sub-classes: \textit{plane} and \textit{cylinder}.  The \textit{plane} class assumes that the plane is perpendicular to one of the three coordinate axes.  This assumption could easily be generalized, but was made to simplify this problem.  The plane is then defined by a point on the plane and the normal vector for the plane.  The \textit{cylinder} class assumes that the cylinder has some origin, a radius, and an axis which extends parallel to the $z$-axis.  Thus, no rotation of the cylinder is allowed.

Both sub-classes of the \textit{surface} class implement several important functions:

\begin{itemize}
\item \textit{double distToIntersect(double*, double*)} -- This function takes a position and direction as input arguments.  It then calculate the distance from the position to the surface along the given direction.  The distances might be negative.
\item \textit{void reflect(double*, double*)} -- This function takes a position and direction.  The direction is modified as if it had reflected off the surface.
\item \textit{int getSense(double*)} -- This function takes a 3D point and returns 1 or -1, depending on where the point is.  For a \textit{plane} class, 1 denotes being on the ``positive'' side of the plane and -1 on the ``negative'' side (with respect to the axis that the plane is perpendicular to), while for a \textit{cylinder} class, 1 denotes being outside the cylinder and -1 denotes being inside it.
\end{itemize}

The \textit{cell} class is defined mostly in terms of surfaces.  It contains a vector of \textit{surface} ID numbers, \textit{iSurfs}, and \textit{senses}, which contains a 1 or -1 for each surface to indicate which side of the surface the cell is on.  It also contains a \textit{material} ID number, and a \textit{distToIntersect} function, which simply calls the corresponding function on each of the \textit{cell}'s \textit{surface} classes and returns the minimum positive distance.

This module also contains two vectors of pointers: one for each \textit{surface} that has been created, and the other for each \textit{cell} that has been created.  The routines \textit{getPtr{\_}cell(int)} and \textit{getPtr{\_}surface(int)} each return a pointer from one of these lists when given an ID number.

The header file is found in Appendix C, and the source file in Appendix D.

\subsection{Materials}\label{ss:materials}

This module contains definitions for the \textit{moderator} and \textit{fuel} classes.  While these classes technically share a superclass \textit{material}, it ended up being simpler for them to be mostly separate.

The \textit{moderator} class contains variables for the oxygen and hydrogen number densities and cross-section (scattering and aborption) parameters.  It also has a function \textit{void modMacro(double, double*, double*, double*)} which, given an energy, returns the total cross-section, the probability of interaction with hydrogen, and the total absorption probability.  These are used to correctly move particles around and perform the interaction physics in the moderator.

The \textit{fuel} class has similar information, but for oxygen, U-235, and U-238.  It also contains fission cross-section and resonance information, which the \textit{moderator} class does not require.  This class has three main methods defined:

\begin{itemize}
\item \textit{void fuelMacro(double, double*, double*, double*)} -- Similar to its \textit{moderator} counterpart, it returns the total cross-section and other information about interaction probabilities.
\item \textit{int sample{\_}U(double, double*, double*, double*, double*)} -- This function uses a random number to determine which isotope of the fuel the neutron is interacting with, and sets appropriate probabilities of absorption and fission based on that result.
\item \textit{double fissXS(double)} -- This function claculates the fission cross-section of U-235 given a particular energy.
\end{itemize}

In addition to these class definitions, this module also contains a routine \textit{void init{\_}materials(int\& , int\& )} which sets up the fuel and moderator materials.  It also defines a function \textit{void elastic(const double, int, double\& , double[3])}, which performs elastic scattering off a material.  There is also a \textit{getPtr{\_}material} function which ended up not being used due to how the materials were defined.

The header file is found in Appendix E, and the source is in Appendix F.

\subsection{Particles}\label{ss:particles}

The header file is found in Appendix G, and the source in Appendix H.

\subsection{Driver}\label{ss:driver}

The driver source code is found in Appendix I.

